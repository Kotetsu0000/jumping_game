# GitHub Copilot プロジェクト指示書: 強制横スクロールアクションゲーム

## 1. プロジェクト概要と目標

このプロジェクトは、JavaScript、p5.js、および p5.play ライブラリを使用して、ブラウザのみで動作する小規模な強制横スクロールアクションゲームを開発することを目的としています。ターゲットプレイヤーはカジュアルゲーマーや暇つぶしを求めるユーザーです。完成したゲームは GitHub Pages で公開します。

**最重要目標:** 複数人での開発を円滑に進めるため、コンフリクトを最小限に抑え、シームレスな共同作業が可能なコードベースと開発プロセスを確立します。Copilot は、この目標を達成するためのコーディング規約、設計パターン、およびワークフローの遵守を支援してください。

## 2. ゲーム内容と仕様

-   **ジャンル:** 強制横スクロールアクション (エンドレスランナー形式)
-   **プレイヤーアクション:** ジャンプのみ。スペースキーまたはマウスクリックでジャンプすることを想定。
-   **スコア:** プレイヤーが進んだ距離（メートルなど、単位は任意）でスコアを競います。スコアは画面に常時表示してください。
-   **ゲームクリア条件:** なし。できるだけ長く進むことを目指します。
-   **ゲームオーバー条件:** プレイヤーキャラクターがステージの足場から落下した場合。ゲームオーバー時にはスコアとリトライオプションを表示してください。
-   **敵キャラクター:** なし。障害物は足場のみとします。
-   **ステージ:** ステージ（足場）は自動生成されます。プレイヤーの進行に合わせて、新しい足場が右側から出現し、左側に消えていくようにしてください。足場の高さや長さにランダム性を持たせ、単調にならないように工夫してください。

## 3. 技術スタックとコーディング標準

-   **言語:** JavaScript (ES6+ のモダンな構文を積極的に使用してください)
-   **主要ライブラリ:**
    -   **p5.js:** 描画、インタラクション、基本的なスケッチ構造に使用します。
    -   **p5.play:** スプライト管理、アニメーション、物理演算（特に衝突判定）、カメラ制御などに活用します。
-   **アセット:**
    -   **ビジュアルスタイル:** ドット絵風を優先してください。実現が難しい場合は、シンプルな幾何学図形でも構いません。Copilot がコードで描画する際は、このスタイルを意識してください。
    -   **色合い:** ポップで明るく、カジュアルなユーザーが親しみやすい配色を心がけてください。例として、`COLOR_PALETTE`のような定数で複数の色を定義し、それを UI やゲーム要素に使用することを提案します。
-   **Linting / Formatting (推奨):** Prettier や ESLint の導入を検討し、チーム内で統一されたコードスタイルを維持してください。Copilot もこれらのツールの設定に基づいたコード生成を心がけてください。(具体的な設定ファイルは別途配置)

## 4. コード構成と設計方針 (推奨)

高品質で保守しやすく、複数人での開発に適したコードベースを目指します。以下のファイル分割とクラス設計を推奨します。Copilot は新しい機能を追加する際、これらの構造に従うように提案してください。

-   **ファイル分割 (ES6 モジュール形式を推奨):**
    -   `sketch.js`: メインの p5.js スケッチファイル。`setup()` と `draw()` 関数を含み、ゲーム全体の初期化とメインループを管理します。各クラスのインスタンス生成や主要なゲームロジックの呼び出しを行います。
    -   `player.js`: `Player` クラスを定義します。
    -   `platform.js` (または `obstacle.js`): `Platform` クラス（足場）を定義します。
    -   `stage_generator.js`: `StageGenerator` クラスまたはモジュールを定義します。
    -   `game_manager.js` (または `ui_manager.js`): `GameManager` クラスを定義します。スコア表示、ゲーム状態の管理、UI 要素の描画などを担当します。
    -   `config.js` (または `constants.js`): ゲーム全体の設定値を定数としてまとめてエクスポートします。
    -   **理由:** 関心の分離を徹底し、各ファイルが単一責任を持つことで、可読性、保守性、再利用性を高め、コンフリクトのリスクを低減します。
-   **クラス設計 (p5.play の Sprite を積極的に活用):**
    -   **`Player` クラス (`player.js`):**
        -   プロパティ: 位置 (x, y)、速度、ジャンプ力、サイズ、現在の状態（例: `grounded`, `jumping`）、p5.play の Sprite オブジェクト。
        -   メソッド: `constructor()`, `update()` (重力適用、移動処理), `jump()`, `display()` (Sprite 経由で描画), `checkCollision()` (足場との衝突判定)。
    -   **`Platform` クラス (`platform.js`):**
        -   プロパティ: 位置 (x, y)、幅、高さ、p5.play の Sprite オブジェクト。
        -   メソッド: `constructor()`, `update()` (画面左へのスクロール処理), `display()` (Sprite 経由で描画), `isOffScreen()` (画面外に出たか判定)。
    -   **`StageGenerator` クラス (`stage_generator.js`):**
        -   プロパティ: 次の足場を生成するタイミングや位置に関するパラメータ。
        -   メソッド: `constructor()`, `update()` (新しい足場を生成・管理), `generateNewPlatform()` (新しい Platform インスタンスを作成して返す), `cleanupPlatforms()` (画面外に出た足場を配列から削除)。
    -   **`GameManager` クラス (`game_manager.js`):**
        -   プロパティ: 現在のゲーム状態 (例: `playing`, `gameOver`)、現在のスコア、ハイスコア。
        -   メソッド: `constructor()`, `updateGame()` (ゲーム状態に応じた処理の振り分け), `updateScore()`, `displayScore()`, `displayGameOverScreen()`, `handleInput()` (ジャンプ入力の受付、リスタート処理)。
-   **設定値の管理 (`config.js`):**
    -   ゲームの挙動を調整するための全ての定数（例: `GRAVITY`, `PLAYER_JUMP_FORCE`, `SCROLL_SPEED`, `PLATFORM_MIN_HEIGHT`, `PLATFORM_MAX_HEIGHT`, `PLATFORM_MIN_WIDTH`, `PLATFORM_MAX_WIDTH`, `PLATFORM_SPAWN_INTERVAL`, `INITIAL_PLAYER_X`, `INITIAL_PLAYER_Y`, `FONT_SIZE_SCORE`, `COLOR_BACKGROUND`, `COLOR_PLAYER`, `COLOR_PLATFORM`, `COLOR_TEXT` など）をこのファイルに集約します。
    -   各モジュールはここから必要な定数をインポートして使用します。マジックナンバーは避けてください。

## 5. AI の振る舞いとワークフローガイドライン

-   **計画の優先:**
    -   複雑な機能の追加や大幅なコード変更を行う前には、まずどのような変更を行うか、どのファイルに影響があるか、どのような手順で進めるかの概要を提示してください。
-   **既存コードの尊重:**
    -   新しいコードを提案する際は、上記「4. コード構成と設計方針」で定義された構造とパターンにできる限り従ってください。
    -   既存のクラスや関数を適切に利用し、不必要に重複したコードを生成しないようにしてください。
-   **p5.js / p5.play のベストプラクティス:**
    -   p5.js の `setup()` と `draw()` の役割を理解し、適切に処理を配置してください。
    -   p5.play の `Sprite` オブジェクトの作成方法、プロパティ設定（位置、速度、コリジョン設定など）、メソッド（`sprite.collide(otherSprite)`など）を効果的に使用してください。
    -   物理演算（重力、衝突）は p5.play の機能を優先的に使用してください。
-   **可読性とコメント:**
    -   生成するコードは、他の開発者が理解しやすいように、適切な変数名、関数名を使用してください。
    -   複雑なロジックや、自明でない処理については、簡潔で分かりやすいコメントを付与することを推奨します。JSDoc 形式のコメントを推奨します。
-   **エラーハンドリング:**
    -   現時点では詳細なエラーハンドリングは必須ではありませんが、予期せぬ挙動を避けるための基本的なチェック（例: オブジェクトの null チェックなど）は適宜行ってください。

## 6. Git と開発フロー

-   **課題管理:** GitHub MCP Server (ユーザー指定のツール) で issue を確認し、作業単位を明確にします。
-   **ブランチ戦略:**
    -   `main` ブランチ: 常にリリース可能な安定版。直接コミットは禁止。
    -   **フィーチャーブランチ:** `main` から作成し、以下の命名規則に従います。
        -   新機能実装: `feature/[issue番号]-[短い説明]` (例: `feature/001-player-jump`)
        -   バグ修正: `fix/[issue番号]-[短い説明]` (例: `fix/002-score-display-error`)
        -   リファクタリング等: `refactor/[issue番号]-[短い説明]`
    -   Copilot がブランチ作成のコマンドを提案する際は、この命名規則を考慮してください。
-   **開発プロセス:**
    1.  issue をアサイン（または自身で選択）。
    2.  `main` ブランチを最新の状態にし、上記の命名規則でフィーチャーブランチを作成・チェックアウト。
    3.  issue の課題解決に取り組みます。Copilot を活用し、上記ガイドラインに沿ったコーディングを行います。
    4.  **テスト(Playwright MCP Server を利用):**
        -   **手動テスト:** 実装した機能がゲーム内で意図通りに動作するかを必ず確認します（ジャンプ、スコア、足場生成、ゲームオーバーなど）。
        -   **ユニットテスト (推奨/導入検討):** `GameManager` のスコア計算ロジックや、`StageGenerator` の特定の生成ルールなど、クリティカルかつ分離可能なロジックに対して、Jest などのフレームワークを用いたユニットテストの作成を検討してください。Copilot はテストコードの雛形作成を支援できます。
    5.  コミットは意味のある単位で行い、コミットメッセージは分かりやすく記述します。
    6.  作業完了後、プルリクエストを `main` ブランチに対して作成します。プルリクエストには、変更内容の概要、関連する issue 番号を明記します。
    7.  チームメンバーによるコードレビューを受け、フィードバックがあれば修正します。
    8.  プルリクエストが承認され `main` ブランチにマージされた後、作業したフィーチャーブランチは削除します。

## 7. その他

-   この指示書はプロジェクトの進行に合わせて更新される可能性があります。
-   不明な点や、より良い提案があれば、積極的にコミュニケーションを取ってください。
